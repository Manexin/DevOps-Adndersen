# Scripting assignments -- task 1****
### So, let's start solving the first problem.
The task is this: there is a large one-liner, it needs to be made into a nice script.

```sh
sudo netstat -tunapl | awk '/firefox/ {print $5}' | cut -d: -f1 | sort | uniq -c | sort | tail -n5 | grep -oP '(\d+\.){3}\d+' | while read IP ; do whois $IP | awk -F':' '/^Organization/ {print $2}' ; done
```
## Разберем по порядку, что делает это однострочник.

1. `netstat` - это утилита командной строки для работы с сетью, для вывода на экран различных сетевых параметров в зависимости от указанных опций.
   `-t` или `--tcp` - показать tcp порты
   `-u` или `--udp` показать udp порты
   `-n` Показывать сетевые адреса как числа. Показывает порты числами а не буквами (443 - https и т.д.)
   `-a` Показывать состояние всех сокетов; обычно сокеты, используемые серверными процессами, не показываются.
   `-p` Отобразить идентификатор/название процесса, создавшего сокет
   `-l` или `--listening` - посмотреть только прослушиваемые порты;
2. `awk '/firefox/ {print $5}'` в выводе команды netstat ищем строки содержащие `firefox` и выводим пятый столбец (ip+port)
3. `cut -d: -f1` отрезаем порты, оставляем только IP
4. `sort` сортируем (по первому символу в строке)
5. `uniq -c` ищем повторы IP адресов и выводим колличество этих повторов
6. `sort` опять сортируем
7. `tail -n5` выводим последние пять IP адресов
8. `grep -oP '(\d+\.){3}\d+'` выводим только IP (одно и более десятичное число с точкой три раза и последний октет IP)
9. Отправляем результат в цикл `while` в котором прогоняем все IP через команду whois. С помощью `awk` ищем строки с `Organization:` и выводим то что после `:` (имя организации)
***
## А теперь разберем зачем этот однострочник это делает и можно ли его упростить

1. Команда `netstat` из устаревшего пакета `net-tools`, вместо нее логичнее было бы использовать `ss` из пакета `iproute2`, она быстрее и короче.
   Параметры возьмем такие же, хотя `-n` можно не указывать, порты мы все равно отрезаем.
2. Если использум `ss` то нужная нам информация будет в `$6` столбце.
3. Тут все так оставляем.
4. Смысл сортировать. Убираем.
5. Проверка IP на уникальность нужна, зачем нам дублирующая информация. Только зачем нам количество повторов, мы с ним чиго не делаем?
   Используем `uniq -u`
6. Опять ненужная сортировка.
7. Тут оставляем как есть. (можно больше строк вывести)
8. Т.к. мы использовали `uniq -u` то в этой операции нет необходимости.
9. Без цикла быдет сложно, оставляем.

```sh
sudo ss -platu | awk '/firefox/ {print $6}' | cut -d: -f1 | uniq -u | tail -n5 | while read IP ; do whois $IP | awk -F':' '/^Organization/ {print $2}' ; done
```
***
## Теперь самое интересное. Мой скрипт.

Зачем нам скрипт только для `firefox` давайте будем указывать соодинения каких приложений нас интересуют.
1. При вызове скрипта передаем ему название которое нас интересует в качестве переменной.
2. Проверяем передали переменную или нет.
3. Если нет выводим сообщение с просьбой указать переменную.
4. Если да, то выполняем наш скрипт постепенно.
5. Промежуточные результаты сохраняем в временные файлы, которые потом удаляем. Пробовал использовать переменные, но с ними были сложности.
6. Если указанное приложение не создает сетевых соеденений, то выводим об этом сообщение.
7. Если соединения есть, прогоняем их через цикл и делаем выборку по `Organization` и `City` (можно и другие поля добавить).
8. Показываем эту иформацию.
9. Для тех IP где эти поля отсутствуют, показываем всю информацию об IP.

### Трудности
Было несколько вариантов скрипта, но этот самый красивый (на мой взгляд).
Были проблемы передать в awk переменную в качестве шаблона. Из многочисленных проб и ошибок этот вариант подошел лучше всего. Интуитивно я его понимаю, но обьснить смогу с трудом.
Не корректно отрабатывает IPv6, поэтому в `ss` указана опция -4. Причину знаю, как решить еще не думал. 
Английский вариант README напишу позже.
